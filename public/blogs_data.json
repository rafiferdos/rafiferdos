{
  "blogs": [
    {
      "id": 1,
      "title": "Building Interactive 3D Globes with Three.js and React",
      "slug": "building-interactive-3d-globes-with-threejs-and-react",
      "date": "May 1, 2025",
      "category": "Web Development",
      "excerpt": "Learn how to create stunning interactive 3D globe visualizations using Three.js and React with optimization techniques for smooth performance.",
      "content": "## Introduction\n\nCreating interactive 3D globes can add a stunning visual element to your web applications. In this tutorial, we'll explore how to build and optimize a 3D globe visualization using Three.js and React.\n\n## Setting Up the Environment\n\nFirst, you'll need to install the necessary dependencies:\n\n```bash\nnpm install three @react-three/fiber @react-three/drei\n```\n\n## Creating the Globe Component\n\nThe core of our globe will be built using Three.js with React Three Fiber as a wrapper to make it more React-friendly:\n\n```tsx\nimport { useEffect, useRef, useState } from 'react';\nimport { Color, Scene, Fog, PerspectiveCamera, Vector3, Group } from 'three';\nimport ThreeGlobe from 'three-globe';\nimport { useThree, Canvas, extend } from '@react-three/fiber';\nimport { OrbitControls } from '@react-three/drei';\n```\n\n## Optimizing Performance\n\nOne key challenge with 3D visualizations is maintaining good performance. Here are some techniques I used:\n\n1. **Dynamic Loading**: Use React's `Suspense` and dynamic imports to only load the 3D components when needed.\n\n2. **Throttling Animations**: Limit the frame rate for certain animations to reduce CPU usage.\n\n3. **Level of Detail (LOD)**: Adjust the complexity of the 3D models based on zoom level or device performance.\n\n## Adding Interactive Features\n\nMake your globe interactive by adding click events, hover effects, and smooth animations between data points.\n\n## Conclusion\n\nBy combining Three.js with React, you can create beautiful and performant 3D globe visualizations that enhance the user experience of your application.",
      "image": "https://framerusercontent.com/images/kJnoVetmlOwLEVfuwWJAYNrng.webp",
      "author": "Rafi Ferdos",
      "tags": ["React", "Three.js", "3D Visualization", "Web Development"]
    },
    {
      "id": 2,
      "title": "Advanced State Management Patterns in React Applications",
      "slug": "advanced-state-management-patterns-in-react-applications",
      "date": "April 15, 2025",
      "category": "Frontend Development",
      "excerpt": "Explore beyond basic Redux implementations with advanced state management patterns that can improve code organization and performance.",
      "content": "## Introduction\n\nAs React applications grow in complexity, so do state management requirements. In this article, we'll explore advanced patterns beyond basic Redux implementation.\n\n## The Context + Reducer Pattern\n\nCombining React's Context API with reducers gives you Redux-like state management without the extra dependencies:\n\n```tsx\n// Create a context\nconst AppStateContext = createContext();\n\n// Define reducer\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'INCREMENT':\n      return { ...state, count: state.count + 1 };\n    default:\n      return state;\n  }\n}\n\n// Provider component\nfunction AppProvider({ children }) {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n    <AppStateContext.Provider value={{ state, dispatch }}>\n      {children}\n    </AppStateContext.Provider>\n  );\n}\n```\n\n## State Machines with XState\n\nFor complex state logic, state machines provide a more declarative and visual way to model your application states:\n\n```tsx\nimport { createMachine, interpret } from 'xstate';\n\nconst toggleMachine = createMachine({\n  id: 'toggle',\n  initial: 'inactive',\n  states: {\n    inactive: { on: { TOGGLE: 'active' } },\n    active: { on: { TOGGLE: 'inactive' } }\n  }\n});\n```\n\n## Optimizing Re-renders\n\nPrevent unnecessary re-renders using techniques like:\n\n1. **State Splitting**: Divide your state into smaller contexts\n2. **Memoization**: Use React.memo, useMemo, and useCallback effectively\n3. **Selectors**: Implement selector patterns similar to reselect\n\n## Persistence and Synchronization\n\nLearn how to persist state across page refreshes and synchronize between tabs using localStorage, IndexedDB, or client-side databases.\n\n## Conclusion\n\nBy implementing these advanced state management patterns, you can build more maintainable and performant React applications that scale with your project's complexity.",
      "image": "https://miro.medium.com/v2/resize:fit:1400/1*HeJahz1pxt_x0E14yF7QfQ.png",
      "author": "Rafi Ferdos",
      "tags": ["React", "State Management", "Context API", "Performance"]
    },
    {
      "id": 3,
      "title": "Building a Serverless API with Next.js API Routes",
      "slug": "building-a-serverless-api-with-nextjs-api-routes",
      "date": "March 22, 2025",
      "category": "Backend Development",
      "excerpt": "Learn how to leverage Next.js API routes to create powerful serverless APIs with authentication, rate limiting, and database integration.",
      "content": "## Introduction\n\nNext.js API routes provide a convenient way to build serverless API endpoints directly within your Next.js application. In this tutorial, we'll build a complete API with authentication, rate limiting, and MongoDB integration.\n\n## Setting Up API Routes\n\nAPI routes are placed in the `pages/api` directory and automatically become endpoints:\n\n```tsx\n// pages/api/users.ts\nimport type { NextApiRequest, NextApiResponse } from 'next';\nimport { connectToDatabase } from '../../lib/mongodb';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  const { db } = await connectToDatabase();\n  \n  switch (req.method) {\n    case 'GET':\n      const users = await db.collection('users').find({}).toArray();\n      res.status(200).json({ users });\n      break;\n    case 'POST':\n      // Handle user creation\n      break;\n    default:\n      res.setHeader('Allow', ['GET', 'POST']);\n      res.status(405).end(`Method ${req.method} Not Allowed`);\n  }\n}\n```\n\n## Adding Authentication\n\nImplement JWT authentication to secure your API endpoints:\n\n```tsx\nimport { verify } from 'jsonwebtoken';\n\n// Middleware to verify JWT\nconst authenticateToken = (handler) => async (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  if (!token) {\n    return res.status(401).json({ message: 'Authentication required' });\n  }\n  \n  try {\n    const decoded = verify(token, process.env.JWT_SECRET);\n    req.user = decoded;\n    return handler(req, res);\n  } catch (error) {\n    return res.status(401).json({ message: 'Invalid token' });\n  }\n};\n\n// Use in API route\nexport default authenticateToken(async function handler(req, res) {\n  // Your protected API logic here\n});\n```\n\n## Implementing Rate Limiting\n\nProtect your API from abuse with a simple rate limiting middleware:\n\n```tsx\nimport { redis } from '../../lib/redis';\n\nconst rateLimit = (handler) => async (req, res) => {\n  const ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress;\n  const key = `rate-limit:${ip}`;\n  \n  const requests = await redis.incr(key);\n  if (requests === 1) {\n    await redis.expire(key, 60);\n  }\n  \n  if (requests > 10) {\n    return res.status(429).json({ message: 'Too many requests' });\n  }\n  \n  return handler(req, res);\n};\n```\n\n## Database Integration\n\nConnect your API to MongoDB for data persistence and use middleware composition for clean code.\n\n## Error Handling and Validation\n\nImplement robust error handling and request validation using libraries like Zod.\n\n## Conclusion\n\nWith Next.js API routes, you can build powerful, secure, and scalable serverless APIs without managing separate backend infrastructure, all while keeping your code in one project.",
      "image": "https://cdn.prod.website-files.com/60acbb950c4d66d0ab3e2007/620ad8da85f234bdf95c3958_cloud-nextjs.jpg",
      "author": "Rafi Ferdos",
      "tags": ["Next.js", "API", "Serverless", "MongoDB", "Authentication"]
    }
  ]
}
